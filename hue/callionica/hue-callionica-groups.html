<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<meta name="apple-mobile-web-app-capable" content="yes" />-->
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Rooms & Zones</title>
    <link rel="stylesheet" href="hue-callionica.css">
    <script type="module">
        import { loadCurrentBridge, loadConnection } from "./hue-callionica-connect.js";
        import { sortBy, getAll, setSensorValue, setGroupOn, setRuleActions, createSchedule, getConnectedComponents, deleteComponent, deleteSchedule, displayLocalTime } from "./hue-callionica.js";
        import { paramsSort } from "./hue-callionica-ui.js";

        import { Switch } from "./hue-callionica-switch.js"

        let bridge;
        let connection;
        let data;

        async function update() {
            if (bridge === undefined) {
                bridge = loadCurrentBridge();
            }

            try {
                if (connection === undefined) {
                    connection = await loadConnection("Callionica", bridge);
                }

                const d = document.getElementById("data");

                data = await getAll(connection);

                let groups = Object.values(data.groups);

                groups.sort(sortBy(g => g.name));

                const params = new URLSearchParams(document.location.search);
                groups = paramsSort(params, groups);

                // const params = new URLSearchParams(document.location.search);

                // function getList(name) {
                //     const p = params.get(name);
                //     return p?.split(",").map(x => x.trim().toLowerCase());
                // }

                // const include = getList("include");
                // if (include) {
                //     // Keep name sorting, but only for the listed items
                //     groups = groups.filter(g => include.includes(g.name.toLowerCase()));

                //     // If we wanted to use the sort order from include as well, we'd do this:
                //     // groups = include.map(n => groups.find(g => n === g.name.toLowerCase())).filter(x=>x);
                // }

                // const exclude = getList("exclude");
                // if (exclude) {
                //     groups = groups.filter(g => !exclude.includes(g.name.toLowerCase()));
                // }

                // let preferred = getList("sort");
                // if (preferred) {
                //     const x = new Array(preferred.length);
                //     const y = [];
                //     for (const group of groups) {
                //         const index = preferred.indexOf(group.name.toLowerCase());
                //         if (index >= 0) {
                //             x[index] = group;
                //         } else {
                //             y.push(group);
                //         }
                //     }

                //     groups = [...x.filter(x => x), ...y];
                // }

                const components = Object.values(data.components);

                const elements = groups.map(group => {
                    const connections = getConnectedComponents(group, data);

                    // console.log(group);
                    // console.log(connections);

                    const powerManagedZone = connections.find(connection => connection.metadata.name === "Power Managed Zone" && connection.metadata.manufacturer === "Callionica");

                    // console.log(powerManagedZone);

                    function summarizeLights(group, data) {
                        if (group.lights.length === 0) {
                            return { anyOn: false, allOn: false, anyUnreachable: true, allUnreachable: true };
                        }

                        let anyOn = false;
                        let allOn = true;
                        let anyUnreachable = false;
                        let allUnreachable = true;

                        for (const lightID of group.lights) {
                            const light = data.lights[lightID];

                            const unreachable = !light.state.reachable;
                            const on = (light.state.on && light.state.reachable);

                            if (on) {
                                anyOn = true;
                            }

                            allOn = allOn && on;

                            if (unreachable) {
                                anyUnreachable = true;
                            }

                            allUnreachable = allUnreachable && unreachable;
                        }

                        return { anyOn, allOn, anyUnreachable, allUnreachable };
                    }

                    function getPowerLevel(pmz) {
                        return pmz?.sensors.find(sensor => sensor.metadata.modelid === "PM.Zone.PowerLevel")?.value;
                    }

                    function getPowerManagement(pmz) {
                        return pmz?.sensors.find(sensor => sensor.metadata.modelid === "PM.Zone.PowerManagement")?.value;
                    }

                    const lights = summarizeLights(group, data);

                    const powerLevel = getPowerLevel(powerManagedZone);
                    const powerManagement = getPowerManagement(powerManagedZone);

                    function create() {
                        const e = document.createElement("div");
                        e.id = "group-" + group.id;
                        e.innerHTML = `<div><span class="group-name"></span><button class="group-toggle" data-action="toggle"></button></div><div class="controls"></div>`;
                        return e;
                    }

                    const e = document.getElementById("group-" + group.id) || create();

                    const ds = e.dataset;

                    ds.group = group.id;
                    ds.type = group.type;

                    ds.anyOn = lights.anyOn;
                    ds.allOn = lights.allOn;
                    ds.anyUnreachable = lights.anyUnreachable;
                    ds.allUnreachable = lights.allUnreachable;

                    if (powerLevel) {
                        ds.powerLevel = powerLevel.value;
                    } else if (ds.powerLevel) {
                        delete ds.powerLevel;
                    }

                    if (powerManagement) {
                        ds.powerManagement = powerManagement.value;
                    } else if (ds.powerManagement) {
                        delete ds.powerManagement;
                    }

                    ds.turnOn = !lights.anyOn;
                    /*if (powerLevel) {
                        ds.turnOn = powerLevel.value < 2;
                    }*/

                    if (powerManagement) {
                        ds.action = "select";

                        const c = e.querySelector(".controls");
                        c.innerHTML = "";

                        // const sw = new Switch(document, c);

                        c.innerHTML = `POWER MANAGED ZONE`;

                        // c.innerHTML = `
                        // <button data-action="scene">SCNE</button>
                        // <button data-action="switch">SWCH</button>
                        // <button data-action="enable">ENBL</button>
                        // <button data-action="control">CTRL</button>
                        // `;
                    }

                    e.querySelector(".group-name").innerText = group.name;
                    e.className = "group";

                    return e;
                });

                let previous = undefined;
                for (const e of elements) {
                    // console.log(e);
                    if (e.parentNode == undefined) {
                        if (previous === undefined) {
                            d.appendChild(e);
                        } else {
                            previous.after(e);
                        }
                    }
                    previous = e;
                }

                if (params.has("group")) {
                    // Move off groups to end
                    // const off = d.querySelectorAll(".group[data-turn-on='true']");
                    // for (const e of [...off]) {
                    //     d.appendChild(e);
                    // }

                    // Move unreachables to the end
                    const unreachable = d.querySelectorAll(".group[data-all-unreachable='true']");
                    for (const e of [...unreachable]) {
                        d.appendChild(e);
                    }
                }
                
                delete document.body.dataset.showConnection;

            } catch (error) {
                document.body.dataset.showConnection = true;

                const e = document.querySelector("#connection");

                e.innerHTML = `<a href="https://${bridge.ip}/api/unauthenticated/config">Check bridge certificate</a>`;

                return;
            }
        }

        async function main() {
            await update();

            async function toggle(groupID, turnOn) {
                const group = data.groups[groupID];
                const connections = getConnectedComponents(group, data);
                const powerManagedZone = connections.find(connection => connection.metadata.name === "Power Managed Zone" && connection.metadata.manufacturer === "Callionica");

                if (powerManagedZone) {
                    // const powerLevelSensor = powerManagedZone.sensors.find(sensor => sensor.modelid === "PM.Zone.PowerLevel")?.id;

                    // await setSensorValue(connection, powerLevelSensor, turnOn ? 2 : 0);

                    const action = powerManagedZone.sensors.find(sensor => sensor.modelid === "PM.Zone.Action")?.id;

                    // Use the dimmer button actions to toggle the lights
                    await setSensorValue(connection, action, turnOn ? 1000 : 4002);
                } else {
                    await setGroupOn(connection, groupID, turnOn);
                }
            }

            function selectAction(e) {
                const removeSelection = (e.dataset.selected === "true");

                let container = e.parentNode;
                while (container) {
                    if (container.dataset.selectGroup === "true") {
                        break;
                    }
                    container = container.parentNode;
                }

                if (container == undefined) {
                    return;
                }

                const selected = container.querySelectorAll("[data-selected='true']");
                for (const s of selected) {
                    delete s.dataset.selected;
                }

                if (!removeSelection) {
                    e.dataset.selected = true;
                } else {
                    delete e.dataset.selected;
                }
            }

            function enableAction(src) {
                while (src && src.dataset.group == undefined) {
                    src = src.parentNode;
                }

                if (src == undefined) {
                    return;
                }

                const groupID = src.dataset.group;

                const group = data.groups[groupID];
                const connections = getConnectedComponents(group, data);
                const powerManagedZone = connections.find(connection => connection.metadata.name === "Power Managed Zone" && connection.metadata.manufacturer === "Callionica");

                if (powerManagedZone) {
                    const sensor = powerManagedZone.sensors.find(sensor => sensor.modelid === "PM.Zone.PowerManagement")?.id;

                    const value = (src.dataset.powerManagement === "0") ?  1 : 0;
                    setSensorValue(connection, sensor, value).then(x => {
                        setTimeout(() => update().then(x => console.log(x)), 0.2 * 1000);
                    });
                }
            }

            function toggleAction(src) {
                while (src && src.dataset.group == undefined) {
                    src = src.parentNode;
                }

                if (src == undefined) {
                    return;
                }

                const id = src.dataset.group;
                const turnOn = src.dataset.turnOn === "true";
                // let turnOn = src.dataset.on === "false";
                // if (src.dataset.powerLevel != undefined) {
                //     turnOn = src.dataset.powerLevel !== "2";
                // }
                toggle(id, turnOn).then(x => {
                    setTimeout(() => update().then(x => console.log(x)), 0.2 * 1000);
                });
            }

            function controlAction(src) {
                while (src && src.dataset.group == undefined) {
                    src = src.parentNode;
                }

                if (src == undefined) {
                    return;
                }

                const id = src.dataset.group;
                document.location = "hue-callionica-components.html"; // TODO
            }

            document.onclick = (evt) => {
                let src = evt.srcElement;
                
                while (src && src.dataset.action == undefined) {
                    src = src.parentNode;
                }
                
                if (src == undefined) {
                    return;
                }

                const action = src.dataset.action;

                if (action === "toggle") {
                    toggleAction(src);
                    return;
                }

                if (action === "select") {
                    selectAction(src);
                    return;
                }

                if (action === "control") {
                    controlAction(src);
                    return;
                }

                if (action === "enable") {
                    enableAction(src);
                    return;
                }
            };

            const updateInterval = 2.0 * 1000;
            window.setInterval(() => {
                update().then(x => console.log("Update"));
            }, updateInterval);
        }

        main().then(x => console.log("Initial"));
        
    </script>
</head>
<body data-page="groups">
    <h1>Rooms & Zones</h1>
    <hr/>
    <div id="connection"></div>
    <div id="data" data-select-group="true"></div>
    <!--<iframe src=""></iframe>-->
</body>
</html>
