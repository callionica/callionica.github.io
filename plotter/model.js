// @ts-check
// deno-lint-ignore-file

import { TEXT_PROPERTIES, HierarchyToken, Line, RelationToken, TargetToken, TextValueToken, ValuesToken, ValueToken } from "./parser.js";

/**
 * Numeric-aware, case-insensitive text comparison for English
 * @param {string} a 
 * @param {string} b 
 */
function compare(a, b) {
    return a.localeCompare(b, "en", { numeric: true, sensitivity: "base" });
}

const ID = "ID";
const IDKey = ID.toLowerCase();
const TAG = "Tag";
const CONTENT = "Content";
const TARGET = "Target";

/**
 * An event that can be published and subscribed to.
 * @template T
 */
class Event {
    constructor() {
        /**
         * The collection of subscribers for the event
         * @type { ((data: T)=>void)[] }
         * */
        this.subscribers = [];

        /**
         * The collection of subscriber/data pairs still to be notified
         * @type { { subscriber: ((data: T)=>void), data: T }[] }
         * */
        this.notifications = [];

        /**
         * Specifies when subscribers will be notified with published data.
         * "manual" requires explicit calls to notify().
         * "immediate" means that notify() is called automatically within the publish() call.
         * "delayed" calls notify() automatically, but in a microtask.
         * @type { "manual" | "immediate" | "delayed" }
         * */
        this.notificationPolicy = "immediate";

        /** @type { boolean } */
        this.queued = false;
    }

    /**
     * Adds an event handler to the list
     * @param {(data: T)=>void} subcriber 
     */
    subscribe(subcriber) {
        this.subscribers.push(subcriber);
        return subcriber;
    }

    /**
     * Removes an event handler from the list
     * @param {(data: T)=>void} subscriber 
     */
    unsubscribe(subscriber) {
        const index = this.subscribers.indexOf(subscriber);
        if (index >= 0) {
            const removed = this.subscribers.splice(index, 1);
            return removed;
        }
    }

    /**
     * Publishes the data for all current subscribers
     * @param { T } data 
     */
    publish(data) {
        // To allow subscribe/unsubscribe/publish from within an event handler
        // we add all the notifications to a queue then process the queue
        // so that a change to the subscribers collection doesn't impact delivery of the
        // notifications. The innermost publish will end up exhausting the notification queue,
        // but it will still deliver notifications in the order they were published.
        const notifications = this.notifications;

        for (const subscriber of this.subscribers) {
            notifications.push({ subscriber, data });
        }

        if (this.notificationPolicy === "immediate") {
            this.notify();
        } else if (this.notificationPolicy === "delayed" && !this.queued) {
            this.queued = true;
            queueMicrotask(() => {
                this.queued = false;
                this.notify();
            });
        }
    }

    notify() {
        const notifications = this.notifications;

        while (notifications.length > 0) {
            // @ts-expect-error shift() can't return undefined here
            const { subscriber, data } = notifications.shift();
            subscriber(data);
        }
    }
}

/**
 * When we just need to notify subscribers of changes, without any data that
 * is specific to an individual change, a fun way to do it is by coalescing all
 * the change notifications into a single callback that is handled by a microtask on
 * the next tick. This can reduce the number of notifications received by subscribers
 * (and, in turn, generated by them if they also need to notify subscribers of changes).
 * 
 * EventChanged provides notification coalescing by keeping track of a single boolean
 * (representing the change) which is set by a call to publish and cleared by a call to notify.
 * 
 * publish is a no-op if the boolean is already true and notify is a no-op if the boolean is false.
 * 
 * Users do not need to call notify explicitly. A call to publish automatically schedules a call to
 * notify using a microtask if one has not already been scheduled.
 */
class EventChanged {

    constructor() {
        /**
         * The collection of subscribers for the event
         * @type { (()=>void)[] }
         * */
        this.subscribers = [];

        /**
         * True if there has been a change since the subscribers were notified
         * @type { boolean }
         */
        this.changed = false;

        /**
         * True if the microtask to notify subscribers has been queued
         * @type { boolean }
         */
        this.queued = false;
    }

    /**
     * Adds an event handler to the list
     * @param {()=>void} subcriber 
     */
    subscribe(subcriber) {
        this.subscribers.push(subcriber);
        return subcriber;
    }

    /**
     * Removes an event handler from the list
     * @param {()=>void} subscriber 
     */
    unsubscribe(subscriber) {
        const index = this.subscribers.indexOf(subscriber);
        if (index >= 0) {
            const removed = this.subscribers.splice(index, 1);
            return removed;
        }
    }

    /**
     * Publish a change.
     * 
     * Calling publish multiple times without intervening calls to notify is a no-op.
     * 
     * You don't need to call notify explicitly. It will be called automatically.
     */
    publish() {
        if (!this.changed) {
            this.changed = true;
            if (!this.queued) {
                this.queued = true;
                queueMicrotask(() => {
                    this.queued = false;
                    this.notify();
                });
            }
        }
    }

    /**
     * Notify subscribers of the change.
     * 
     * You don't need to call this directly, since it will be called
     * automatically by a microtask that is triggered by a call to publish.
     * 
     * Calling notify multiple times without intervening calls to publish is a no-op.
     */
    notify() {
        if (this.changed) {
            this.changed = false;
            const subscribers = [...this.subscribers];
            for (const subscriber of subscribers) {
                subscriber();
            }
        }
    }
}

/**
 * @template T
 * @typedef { { added: T[], at: number } | { removed: T[], at: number } | undefined } ListNotification
 */

/**
 * An array-like structure that fires events when items are added/removed 
 * @template T
 */
class List {
    constructor() {
        /** @type { T[] } */
        this.items_ = [];

        /** @type { Event<ListNotification<T>> } */
        this.changed = new Event();
    }

    /**
     * Called when items have been added, moved, or removed.
     * If no data is provided, discard all data.
     * @param { ListNotification<T> } [data]
     */
    onChanged(data) {
        this.changed.publish(data);
    }

    get length() {
        return this.items_.length;
    }

    /**
     * @param { number } index 
     */
    at(index) {
        return this.items_[index];
    }

    [Symbol.iterator]() {
        return this.items_[Symbol.iterator]()
    }

    /**
     * Yields [index, item] for each item in the list
     * @param { number? } [index] The index of the first entry to yield
     */
    *entries(index) {
        if (this.isEmpty) {
            return;
        }

        index = Math.max(index ?? 0, 0);

        for (let i = index; i < this.items_.length; ++i) {
            yield /** @type { [ number, T] } */ ([i, this.items_[i]]);
        }
    }

    /**
     * Yields [index, item] for each item in the list in reverse order
     * @param { number? } [index] The index of the first entry to yield
     */
    *entriesReverse(index) {
        if (this.isEmpty) {
            return;
        }

        const lastIndex = this.length - 1;
        index = Math.min(index ?? lastIndex, lastIndex);

        for (let i = index; i >= 0; --i) {
            yield /** @type { [ number, T] } */ ([i, this.items_[i]]);
        }
    }

    /**
     * @returns { T | undefined }
     */
    get first() {
        return this.items_[0];
    }

    /**
     * @returns { T | undefined }
     */
    get last() {
        return this.items_[this.items_.length - 1];
    }

    get isEmpty() {
        return this.length === 0;
    }

    /**
     * 
     * @param { T } item 
     * @param { number | undefined } [index] 
     */
    add(item, index) {
        if (index === undefined) {
            index = this.length;
        }

        index = Math.min(Math.max(index, 0), this.length);

        this.items_.splice(index, 0, item);
        this.onChanged({ added: [item], at: index });
    }

    /**
     * 
     * @param { T | number } item 
     */
    remove(item) {
        const index = /** @type { number } */ (typeof item === "object" ? this.items_.indexOf(item) : item);
        if (index >= 0) {
            const removed = this.items_.splice(index, 1);
            this.onChanged({ removed, at: index });
        }
    }

    clear() {
        if (!this.isEmpty) {
            this.items_ = [];
            this.onChanged(undefined);
        }
    }

    /**
     * @param {string | undefined} separator
     */
    join(separator) {
        return this.items_.join(separator);
    }
}

/**
 * Key is a case-preserving shared string that can be compared in a case-insensitive way
 * */
export class Key {
    /**
     * @param { string } name 
     */
    constructor(name) {
        this.name_ = name;
        this.key_ = name.toLowerCase();
    }

    /**
     * INTERNAL!
     * @param { string } name 
     * @param { string | undefined } [key]
     */
    rename(name, key) {
        this.name_ = name;
        this.key_ = key ?? name.toLowerCase();
    }

    get name() {
        return this.name_;
    }

    get key() {
        return this.key_;
    }

    /**
     * @param { Key } other 
     */
    compare(other) {
        if (this === other) {
            return 0;
        }
        return compare(this.key, other.key);
    }

    toString() {
        return this.name_;
    }
}

/** A key representing a property name */
export class PropertyKey extends Key { }

/** A key representing a private property name */
export class PrivatePropertyKey extends PropertyKey { }

/** A key representing a relation name */
export class RelationKey extends Key { }

/** A key representing (part of) a value */
export class ValueKey extends Key { }

/**
 * Keys is a collection of keys
 * @template { Key } T
 */
export class Keys {
    /**
     * @param { string[] } names 
     * @param { { new(name: string) : T } } cls
     */
    constructor(names = [], cls) {
        this.cls = cls;

        /** @type { Map<string, T[]> } */
        this.keys_ = new Map();
        for (const name of names) {
            this.ensureKey(name);
        }
    }

    /**
     * Creates or retrieves a key for the specified name
     * @param { string } name 
     */
    ensureKey(name) {
        const key = new this.cls(name);

        const existing = this.keys_.get(key.key);
        if (existing !== undefined) {
            return existing[0];
        }

        this.keys_.set(key.key, [key]);

        return key;
    }

    /**
     * Gets a key for the specified name if one exists
     * @param { string } name 
     */
    getKey(name) {
        return this.keys_.get(name.toLowerCase())?.[0];
    }

    /**
     * Renames a key if it exists under the old name.
     * Also renames (changes the capitalization of) any existing keys with that name.
     * @param { object } options
     * @param { string } options.oldName The old name of the key
     * @param { string } options.newName The new name of the key
     */
    renameKey({ oldName, newName }) {
        // We want to enable renames without forcing new keys into all the objects
        // so we keep all existing Keys in a collection under their key
        // and update the name and key properties of those objects.
        // This way we can have 100000 objects that reference a single key
        // and update their names with just a single update.
        // The cost is that instead of having a string->Key map, we need a string->Key[] map
        // to account for the case where a key is renamed to the same name as an existing key.
        const oldKey = oldName.toLowerCase();
        const newKey = newName.toLowerCase();

        const oldKeys = this.keys_.get(oldKey);
        const newKeys = this.keys_.get(newKey) ?? [];

        if (oldKeys !== undefined) {
            this.keys_.delete(oldKeys[0].key);

            if (oldKeys !== newKeys) {
                newKeys.push(...oldKeys);
            }

            for (const key of newKeys) {
                // All keys share the same name and key strings
                key.rename(newName, newKey);
            }

            this.keys_.set(newKey, newKeys)

            return newKeys[0];
        }
    }
}

/**
 * Document represents a collection of data
 * consisting of a list of items where each item has zero or more 
 * properties with zero or more values.
 */
export class Document {
    /**
     * 
     * @param { string } storageKey The key used for storing the data to disk
     */
    constructor(storageKey) {
        this.storageKey_ = storageKey;

        /** @type { Map<PropertyKey, Keys<ValueKey>> } */
        this.valueKeys = new Map();

        this.propertyKeys = new Keys([
            ID,
            TAG,
            "Time", "Sequence",
            "Title", "Content", "Note"
        ], PropertyKey);

        this.relationKeys = new Keys(["Before", "After", "Same"], RelationKey);

        // We couldn't (easily) allow property keys to be renamed if reference targets and IDs
        // were to use the same property key, so we use an internal property key for targets
        // and let value renaming for the ID property also cause value renaming on the :Target property.
        this.targetKey = new PrivatePropertyKey(TARGET);

        /** @type { List<Item> } */
        this.items_ = new List();

        /** @type { Event<{ propertyKeys?: PropertyKey[], items?: Item[] }> } */
        this.propertyChanged_ = new Event();

        /** @type { EventChanged } */
        this.changed_ = new EventChanged();

        this.items_.changed.subscribe((data) => this.onListChanged(data));

        /** @type { string[] } */
        this.undoStack = [];

        /** @type { string[] } */
        this.redoStack = [];

        this.changed_.subscribe(() => {
            const text = this.toString();
            this.undoStack.push(text);
            queueMicrotask(() => {
                localStorage.setItem(this.storageKey_, text);
            });
        });
    }

    undo() {
        if (this.undoStack.length >= 2) {
            const current = this.undoStack.pop();
            if (current !== undefined) {
                // Push the current state to the redo stack
                this.redoStack.push(current);

                // Pop the older state and load it
                const newCurrent = this.undoStack.pop();
                if (newCurrent !== undefined) {
                    this.clearItems();
                    this.load(newCurrent);
                }
            }
        }
    }

    redo() {
        const newCurrent = this.redoStack.pop();
        if (newCurrent !== undefined) {
            this.clearItems();
            this.load(newCurrent);
        }
    }

    /**
     * Loads a document from text
     * @param { string } text The data to load
     * @param { number | undefined } [index] The index at which to create the first item
     */
    load(text, index) {
        
        if (index === undefined) {
            index = this.items.length;
        }

        const start = index;

        let item;
        let content;
        const textLines = text.split("\n");

        for (const textLine of textLines) {
            const line = new Line(textLine);
            switch (line.category()) {
                case "whitespace":
                    if (item !== undefined) {
                        if (content !== undefined) {
                            for (const value of content) {
                                item.addValue("content", value);
                            }
                            content = undefined;
                        }
                        item = undefined;
                    }
                    break;
                case "property":
                    if (item === undefined) {
                        item = this.createItem(index);
                        ++index;
                    }
                    const property = line.id() ?? "";
                    if (TEXT_PROPERTIES.includes(property)) {
                        const text = line.tokens().find(t => t instanceof TextValueToken)?.text(textLine) ?? "";
                        item.addValue(property, text);
                    } else {
                        const values = line.valueTokens().map(token => valueTokenToObject(this, property, token, textLine));
                        for (const value of values) {
                            item.addValue(property, value);
                        }
                    }
                    break;
                case "content":
                    if (item === undefined) {
                        item = this.createItem(index);
                        ++index;
                    }
                    if (content === undefined) {
                        content = [textLine];
                    } else {
                        content.push(textLine);
                    }
                    break;
            }
        }

        if (item !== undefined) {
            if (content !== undefined) {
                for (const value of content) {
                    item.addValue("content", value);
                }
                content = undefined;
            }
            item = undefined;
        }

        return { start, end: index };
    }

    get changed() {
        return this.changed_;
    }

    get listChanged() {
        return this.items_.changed;
    }

    get propertyChanged() {
        return this.propertyChanged_;
    }

    get items() {
        return this.items_;
    }

    /**
     * Returns a list of items in the specified order with each item preceded by the index of that item in document order.
     * @param { "document" | "sequence" | "time" } order 
     * @returns { [number, Item][] }
     */
    ordered(order) {
        if (order === "document") {
            return [...this.items_.items_.entries()];
        }

        // We want to use ordered() which operates on Items,
        // but we also want to keep track of the original index
        // and we want to return the original Items so that reference equality works

        /** @type { (Item & { true_index: number, true_item: })[] } */
        const items = this.items_.items_.map((item, index) => {
            const o = Object.create(item);
            o.true_index = index;
            o.true_item = item;
            return o;
        });

        return ordered(items, order).map(i => ([i.true_index, i.true_item]));
    }

    /**
     * @param { string | PropertyKey} property 
     */
    ensurePropertyKey(property) {
        return property instanceof PropertyKey ? property : this.propertyKeys.ensureKey(property);
    }

    /**
     * @param { string | PropertyKey} property 
     * @param { string } name 
     */
    ensureKey(property, name) {
        const propertyKey = this.ensurePropertyKey(property);
        const keys = this.valueKeys.get(propertyKey) ?? (() => {
            const keys = new Keys([], ValueKey);
            this.valueKeys.set(propertyKey, keys);
            return keys;
        })();

        if ((propertyKey.key === IDKey) && (keys.getKey(name) === undefined)) {
            // We have a new ID key, so case-correct any target keys
            this.renameKey(this.targetKey, { oldName: name, newName: name });
        }

        return keys.ensureKey(name);
    }

    /**
     * @param { string | PropertyKey} property 
     * @param { string } name 
     */
    getKey(property, name) {
        const propertyKey = this.ensurePropertyKey(property);;
        const keys = this.valueKeys.get(propertyKey);
        if (keys !== undefined) {
            return keys.getKey(name);
        }
    }

    /**
     * Rename a value key for the specified property
     * @param { string | PropertyKey } property
     * @param { { oldName: string, newName: string} } options 
     */
    renameKey(property, options) {
        const propertyKey = this.ensurePropertyKey(property);
        const keys = this.valueKeys.get(propertyKey);
        if (keys !== undefined) {

            // If renaming an ID value, also rename the :Target value.
            if (propertyKey.key === IDKey) {
                const targetKeys = this.valueKeys.get(this.targetKey);
                if (targetKeys !== undefined) {
                    targetKeys.renameKey(options);
                    // No event is fired here, the :Target value is not public
                    // and listeners should watch for changes to the ID value only
                }
            }

            const result = keys.renameKey(options);
            this.onPropertyChanged({ propertyKeys: [propertyKey] });
            return result;
        }
    }

    /**
     * @param { string | PropertyKey } property 
     * @param { string[] } levels
     */
    createHierarchy(property, levels) {
        const propertyKey = this.ensurePropertyKey(property);
        if (propertyKey === this.targetKey) {
            // If dealing with a target, we use the name from the ID if it exists already
            const id = this.ensurePropertyKey(ID);
            const betterLevels = levels.map(level => this.getKey(id, level)?.name ?? level);
            return new ValueHierarchy(betterLevels.map(level => this.ensureKey(propertyKey, level)));
        }
        return new ValueHierarchy(levels.map(level => this.ensureKey(propertyKey, level)));
    }

    /**
     * Create a tag value
     * @param { string } tag
     */
    createTag(tag) {
        return this.createHierarchy(TAG, [tag]);
    }

    /**
     * Create a unique value from a template
     * by incrementing the final level until it's unique
     * @param { string | PropertyKey } property 
     * @param { string | string[] | Value } template
     */
    unique(property, template, increment = 1) {
        if (template instanceof Value) {
            if (template instanceof ValueHierarchy) {
                template = template.toString();
            } else {
                return undefined;
            }
        }
        const levels = Array.isArray(template) ? [...template] : template.split(".");

        const re = /^(?<prefix>.*\D)?(?<number>\d+)$/i;
        const m = levels[levels.length - 1].match(re) ?? undefined;
        if (m === undefined) {
            return undefined;
        }
        const groups = /** @type { { prefix: string, number: string } } */ (m.groups);
        const prefix = groups.prefix ?? "";
        const endValue = parseInt(groups.number, 10);
        if (!isFinite(endValue)) {
            return undefined;
        }
        const prop = this.ensurePropertyKey(property);

        let index = 0;
        while (true) {
            levels[levels.length - 1] = `${prefix}${endValue + index}`;
            const current = this.createHierarchy(prop, levels);
            if (!this.items.items_.some(item => item.hasHierarchyValue(prop, current))) {
                return current;
            }
            index += increment;
        }
    }

    /**
     * @param { string | string[] } template
     */
    bump(template, increment = 1) {
        const levels = Array.isArray(template) ? [...template] : template.split(".");
        const re = /^(?<prefix>.*\D)?(?<number>\d+)$/i;
        const m = levels[levels.length - 1].match(re) ?? undefined;
        if (m !== undefined) {
            const groups = /** @type { { prefix: string, number: string } } */ (m.groups);
            const prefix = groups.prefix ?? "";
            const endValue = parseInt(groups.number, 10);
            if (isFinite(endValue)) {
                levels[levels.length - 1] = `${prefix}${endValue + increment}`;
            }
        }
        return levels.join(".");
    }

    /**
     * @param { string | RelationKey } relation
     * @param { string[] } target 
     */
    createReference(relation, target) {
        const relationKey = relation instanceof RelationKey ? relation : this.relationKeys.ensureKey(relation);
        return new ValueReference(relationKey, this.createHierarchy(this.targetKey, target));
    }

    /**
     * @param { string } text 
     */
    createText(text) {
        return new ValueText(text);
    }

    /**
     * 
     * @param { number | undefined } index
     */
    createItem(index = undefined) {
        const item = new Item(this);
        this.items_.add(item, index);
        return item;
    }

    /**
     * @param { Item } item 
     */
    removeItem(item) {
        this.items_.remove(item);
    }

    clearItems() {
        this.items_.clear();
    }

    /**
     * Called when a property is added to an item, removed from an item, or changed.
     * If no items are provided, assume that the given properties for all items could have changed.
     * If no properties are provided, assume that all properties for the given items could have changed. (This will be the case, when properties are reordered)
     * @param { { propertyKeys?: PropertyKey[], items?: Item[] } } data 
     */
    onPropertyChanged(data) {
        this.propertyChanged.publish(data);
        this.changed.publish();
    }

    /**
     * Called when items have been added, moved, or removed from the document.
     * If no data is provided, discard all data and refresh both the list and the properties
     * of any items.
     * @param { ListNotification<Item> } [data]
     */
    onListChanged(data) {
        this.changed.publish();
    }

    toString() {
        return this.items_.join("\n\n");
    }
}

export class Item {
    /**
     * @param { Document } document 
     */
    constructor(document) {
        this.document_ = document;

        /** @type { List<Property> } */
        this.properties_ = new List();
    }

    get document() {
        return this.document_;
    }

    get properties() {
        return this.properties_;
    }

    /**
     * @param { string | PropertyKey } property
     */
    *getProperties(property) {
        const propertyKey = this.propertyKey(property);
        for (const property of this.properties) {
            if (property.key === propertyKey) {
                yield property;
            }
        }
    }

    /**
     * @template { Value } T
     * @param { string | PropertyKey } property
     * @param { { new(...args: any[]): T } } [cls]
     */
    *getValues(property, cls) {
        const propertyKey = this.propertyKey(property);
        if (propertyKey !== undefined) {
            for (const property of this.properties) {
                if (property.key === propertyKey) {
                    for (const value of property.values) {
                        if ((cls === undefined) || value instanceof cls) {
                            yield /** @type { T } */ (value);
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns an existing property key for the specified property
     * @param { string | PropertyKey } property 
     */
    propertyKey(property) {
        return property instanceof PropertyKey ? property : this.document.propertyKeys.getKey(property);
    }

    /**
     * Returns the first property with the specified propertyKey
     * @param { string | PropertyKey } property 
     */
    property(property) {
        for (const p of this.getProperties(property)) {
            return p;
        }
    }

    /**
     * Returns the first hierarchy value from the property with the specified propertyKey
     * @param { PropertyKey } propertyKey 
     */
    value(propertyKey) {
        for (const value of this.getValues(propertyKey, ValueHierarchy)) {
            return value;
        }
    }

    /**
     * Creates a new prop with the specified propertyKey
     * @param { string | PropertyKey } property
     */
    createProperty(property) {
        const propertyKey = this.document.ensurePropertyKey(property);
        const prop = new Property(this, propertyKey);
        this.properties_.add(prop);
        this.document_.onPropertyChanged({ propertyKeys: [propertyKey], items: [this] });
        return prop;
    }

    /**
     * Returns an existing property or creates a new property with the specified propertyKey
     * @param { string | PropertyKey } property
     */
    ensureProperty(property) {
        const existing = this.property(property);
        if (existing !== undefined) {
            return existing;
        }
        return this.createProperty(property);
    }

    /**
     * @param { Property } property 
     */
    removeProperty(property) {
        const _removed = this.properties_.remove(property);
        this.document.onPropertyChanged({ propertyKeys: [property.key], items: [this] });
    }

    /**
     * @param { string | PropertyKey } property
     * @param { string | string[] | Value } value
     */
    addValue(property, value) {
        const p = this.ensureProperty(property);
        const v = value instanceof Value ? value : Array.isArray(value) ? this.document.createHierarchy(p.key, value) : this.document.createText(value);
        p.addValue(v);
    }

    /**
     * @param { string } tag
     */
    addTag(tag) {
        this.addValue(TAG, [tag]);
    }

    /**
     * @param { string | PropertyKey } property
     * @param { string | string[] | Value } value
     */
    setValue(property, value) {
        const p = this.ensureProperty(property);
        const v = value instanceof Value ? value : Array.isArray(value) ? this.document.createHierarchy(p.key, value) : this.document.createText(value);
        p.setValues([v]);
    }

    /**
     * @param { string | PropertyKey } property
     * @param { ValueHierarchy } value
     */
    hasHierarchyValue(property, value) {
        const p = this.ensureProperty(property);
        for (const v of this.getValues(property, ValueHierarchy)) {
            if (v.equals(value)) {
                return true;
            }
        }
        return false;
    }

    toString() {
        const result = [];
        let content;
        for (const property of this.properties) {
            if (property.key.key === "content") {
                content = property.toString();
            } else {
                result.push(property.toString());
            }
        }

        if (content !== undefined) {
            result.push(content);
        }

        return result.join("\n");
    }
}

export class Property {
    /**
     * @param { Item } item 
     * @param { PropertyKey | string } property
     */
    constructor(item, property) {
        this.item_ = item;
        this.key_ = item.document.ensurePropertyKey(property);

        /** @type { Value[] } */
        this.values_ = [];
    }

    get document() {
        return this.item_.document;
    }

    get item() {
        return this.item_;
    }

    get key() {
        return this.key_;
    }

    get values() {
        return this.values_;
    }

    toString() {
        if (this.key.key === "content") {
            return this.values.join("\n");
        } else if (TEXT_PROPERTIES.includes(this.key.key)) {
            return this.values.map(value => `${this.key.name}: ${value}`).join("\n");
        }

        return `${this.key.name}: ${this.values.join(", ")}`;
    }

    /**
     * @param { Value } value 
     */
    hasValue(value) {
        return this.values_.some(v => v.equals(value));
    }

    /**
     * @param { Value } value 
     */
    addValue_(value) {
        if (!this.hasValue(value)) {
            this.values_.push(value);
            return true;
        }
        return false;
    }

    /**
     * @param { Value } value 
     */
    addValue(value) {
        if (this.addValue_(value)) {
            this.onChanged();
        }
    }

    /**
     * @param { Value } value 
     */
    removeValue(value) {
        const index = this.values_.indexOf(value);
        if (index >= 0) {
            const _removed = this.values_.splice(index, 1);
            this.onChanged();
        }
    }

    /**
     * @param { Iterable<Value> } values
     */
    setValues(values) {
        this.values_ = []
        for (const value of values) {
            this.addValue_(value);
        }
        this.onChanged();
    }

    onChanged() {
        this.document.onPropertyChanged({ propertyKeys: [this.key], items: [this.item] });
    }
}

/** Base class for all value types */
export class Value {
    constructor() {
    }

    /**
     * @param { Value } other 
     */
    equals(other) {
        return false;
    }
}

/**
 * A value that refers from the owning item to another item.
 * The value contains the ID of the target item and the relationship
 * between the items.
 * 
 * "The owning item is ${relation} the target item"
 * */
export class ValueReference extends Value {
    /**
     * @param { RelationKey } relation 
     * @param { ValueHierarchy } target 
     */
    constructor(relation, target) {
        super();
        this.relation_ = relation;
        this.target_ = target;
    }

    get relation() {
        return this.relation_;
    }

    get target() {
        return this.target_;
    }

    toString() {
        return `${this.relation.name}:${this.target}`;
    }

    /**
     * @param { Value } other 
     * @returns { boolean }
     */
    equals(other) {
        if (other instanceof ValueReference) {
            return (this.relation.compare(other.relation) === 0) && (this.target.compare(other.target) === 0);
        }
        return false;
    }
}

/**
 * A value that consists of pieces or levels.
 * These can be used for equality and ordering.
 * Each level is case-insensitive and shared as a Key.
 */
export class ValueHierarchy extends Value {
    /**
     * @param { ValueKey[] } keys 
     */
    constructor(keys) {
        super();
        this.keys_ = keys;
    }

    get keys() {
        return this.keys_;
    }

    toString() {
        return this.keys_.join(".");
    }

    /**
     * 
     * @param {ValueHierarchy} rhs 
     * @returns 
     */
    compare(rhs) {
        const count = Math.min(this.keys.length, rhs.keys.length);

        for (let i = 0; i < count; ++i) {
            const cmp = this.keys[i].compare(rhs.keys[i]);
            if (cmp !== 0) {
                return cmp;
            }
        }

        if (this.keys.length < rhs.keys.length) {
            return -1;
        }

        if (this.keys.length > rhs.keys.length) {
            return +1;
        }

        return 0;
    }

    /**
     * @param { Value } other 
     * @returns { boolean }
     */
    equals(other) {
        if (other instanceof ValueHierarchy) {
            return this.compare(other) === 0;
        }
        return false;
    }
}

/**
 * A value that consists of text.
 * The Title and Content properties use text values.
 */
export class ValueText extends Value {
    /**
     * @param { string } text 
     */
    constructor(text) {
        super();
        this.text_ = text;
    }

    get text() {
        return this.text_;
    }

    toString() {
        // @ts-ignore
        return this.text_.replaceAll("\n\n", "\n.");
    }
}

/**
 * @template { { readonly document: Document, value(propertyKey: PropertyKey): ValueHierarchy | undefined } } T
 * @param { T[] } items 
 * @param { string | PropertyKey } property 
 */
function fixedOrder(items, property) {
    if (items.length === 0) {
        return [];
    }
    const document = items[0].document;
    const propertyKey = document.ensurePropertyKey(property);

    /** @type { { value: ValueHierarchy, items: T[] } } */
    let group = { value: new ValueHierarchy([]), items: [] };
    const groups = [group];
    for (const item of items) {
        const value = item.value(propertyKey);
        if ((value !== undefined) && group.value.compare(value) !== 0) {
            group = { value: value, items: [item] };
            groups.push(group);
        } else {
            group.items.push(item);
        }
    }

    groups.sort((a, b) => {
        return a.value.compare(b.value);
    });

    return groups.flatMap(g => g.items);
}

/**
 * @template { Item } T
 * @param { T[] } items 
 * @param { string | PropertyKey } property 
 */
export function ordered(items, property) {
    // Order based on fixed values for this property
    items = fixedOrder(items, property);

    /** @typedef { { previous: OrderingNode[], same: OrderingNode[], item: T } } OrderingNode */

    // Initialize graph objects
    const orderingNodes = items.map(item => /** @type { OrderingNode } */({ previous: [], same: [], item }));

    /**
     * 
     * @param { OrderingNode } orderingNode 
     * @param { "before" | "same" | "after" } relation 
     * @returns { OrderingNode[] }
     */
    function getReferences(orderingNode, relation) {
        return /** @type { OrderingNode[] } */ ([...orderingNode.item.getValues(property, ValueReference)].filter(r => r.relation.key === relation).map(reference => {
            // We're trading off perf against predicatbility here!
            // The most predicatble thing would be to resolve the ID to an item using
            // source order to ensure that items earlier in the source order are chosen
            // if there is a conflict then to get the matchiing ordering node.
            // Instead, we go directly to the ordering node using the order defined by 
            // fixedOrder for this property. This only has an effect if there are multiple
            // items with the same ID though.
            return orderingNodes.find(on => on.item.hasHierarchyValue(ID, reference.target));
        }).filter(x => x));
    }

    // Add previous items
    for (const orderingNode of orderingNodes) {
        const befores = getReferences(orderingNode, "before");
        for (const before of befores) {
            before.previous.push(orderingNode);
        }

        const sames = getReferences(orderingNode, "same");
        for (const same of sames) {
            orderingNode.same.push(same);
            same.same.push(orderingNode);
        }

        const afters = getReferences(orderingNode, "after");
        for (const after of afters) {
            orderingNode.previous.push(after);
        }
    }


    // Mark the current item
    // Yield any previous items not marked
    // Yield the current item
    /**
     * @param { OrderingNode } item 
     * @param { Set<OrderingNode> } history 
     * @returns { IterableIterator<T> }
     */
    function* each(item, history) {
        if (history.has(item)) {
            return;
        }

        history.add(item);

        for (const previousItem of item.previous) {
            yield* each(previousItem, history);
        }

        yield item.item;

        // "same" items could go before or after the main item,
        // but after feels better to preserve document order
        for (const previousItem of item.same) {
            yield* each(previousItem, history);
        }
    }

    const history = new Set();
    return orderingNodes.flatMap(item => [...each(item, history)])
}

/** @typedef { ValueHierarchy } Tag */

/**
 * An object that stores the state necessary to include/exclude items
 * in a collection. Used to provide different views of the document.
 */
export class FilterItems {
    /**
     * @param { string } name 
     */
    constructor(name) {
        /** @type { string } */
        this.name = name;

        /** @type { Tag[] } */
        this.includeTags = [];

        /** @type { Tag[] } */
        this.excludeTags = [];
    }

    /**
     * Returns true if the filter allows the item to be shown
     * @param { Item } item 
     */
    allow(item) {
        // If no include tags, all items are allowed (unless excluded)
        // Otherwise, items are only allowed if they have at least one inlude tag (unless excluded)
        // Items are excluded if they have at least one of the exclude tags
        let allowed = this.includeTags.length === 0;
        const tagProperty = /** @type { PropertyKey } */ (item.propertyKey(TAG));
        for (const tag of item.getValues(tagProperty, ValueHierarchy)) {
            if (this.excludeTags.find(t => t.compare(tag) === 0)) {
                allowed = false;
                break;
            }

            if (!allowed && this.includeTags.find(t => t.compare(tag) === 0)) {
                allowed = true;
            }
        }
        return allowed;
    }
}

/**
 * An object that stores the state necessary to include/exclude properties
 * in a collection. Used to provide different views of the document.
 */
export class FilterProperties {
    /**
     * @param { string } name 
     */
    constructor(name) {
        this.name = name;

        /**
         * Lists the properties that will be shown and the order in which they'll be shown.
         * Unknown properties are sorted to the end and put in alpha order.
         * @type { PropertyKey[] }
         * */
        this.include = [];
    }

    /**
     * Returns true if the filter allows the property to be shown
     * @param { Property } property 
     */
    allow(property) {
        if (this.include.length === 0) {
            return true;
        }
        const allowed = this.include.some(pk => property.key.compare(pk) === 0);
        return allowed;
    }

    get compare() {
        /**
         * @param { Property } a
         * @param { Property } b
         */
        return (a, b) => {
            const order = this.include;

            let indexA = order.indexOf(a.key);
            if (indexA < 0) {
                indexA = order.length;
            }

            let indexB = order.indexOf(b.key);
            if (indexB < 0) {
                indexB = order.length;
            }

            if (indexA < indexB) {
                return -1;
            }

            if (indexB < indexA) {
                return +1;
            }

            return a.key.compare(b.key);
        };
    }

    /**
     * @param { Item } item 
     */
    *_properties(item) {
        for (const property of item.properties) {
            if (this.allow(property)) {
                yield property;
            }
        }
    }

    /**
     * @param { Item } item 
     */
    properties(item) {
        return [...this._properties(item)].sort(this.compare);
    }
}

/**
 * @typedef { {
 *      readonly item: Item,
 *      readonly index: number,
 *      readonly viewIndex: number,
 *      readonly properties: Property[]
 * } } ViewItem
 */

/**
 * A view is a subset of items/properties defined by a
 * document, an item filter, and a property filter.
 * It provides a current property that keeps track of the
 * current property.
 */
export class View {
    /**
     * @param { Document } document 
     */
    constructor(document) {
        /** @type { Document } */
        this.document = document;

        /** @type { FilterItems } */
        this.itemFilter_ = new FilterItems("");

        /** @type { FilterProperties } */
        this.propertyFilter_ = new FilterProperties("");

        /** @type { "document" | "sequence" | "time" }  */
        this.sorting_ = "document";

        /** @type { EventChanged } */
        this.changedInternal = new EventChanged();

        /** @type { EventChanged } */
        this.changed = new EventChanged();

        /** @type { IterableX<ViewItem> } */
        this.items_ = new IterableX([]);

        /** @type { ViewItem[] } */
        this.selected_ = [];

        this.changedInternal.subscribe(() => this.onChanged());
        this.document.changed.subscribe(() => this.changedInternal.publish());

        this.onChanged();
    }

    get items() {
        return this.items_;
    }

    get itemFilter() {
        return this.itemFilter_;
    }

    set itemFilter(value) {
        this.itemFilter_ = value;
        this.changedInternal.publish();
    }

    get propertyFilter() {
        return this.propertyFilter_;
    }

    set propertyFilter(value) {
        this.propertyFilter_ = value;
        this.changedInternal.publish();
    }

    get sorting() {
        return this.sorting_;
    }

    set sorting(value) {
        this.sorting_ = value;
        this.changedInternal.publish();
    }

    /** Returns the current item (the last item of the selection in view order) */
    get current() {
        const range = this.selectionRange;
        return this.selected_[range.maxIndex];
    }

    selectionAsData() {
        return this.itemsAsData(this.selected_);
    }

    /**
     * Returns the list of items as text data
     * @param { Iterable<ViewItem> } items 
     */
    itemsAsData(items) {
        // Sort the selection into document order
        const selected = [...items].sort((a, b) => a.index - b.index).map(vi => vi.item);
        // Then use toString to get the data
        return selected.join("\n\n");
    }

    get active() {
        return new IterableX(this.selected_).at(-1);  
    }

    /**
     * Sets the selection to the given item.
     * (Does not delete any items!)
     * @param { ViewItem | undefined } viewItem
     */
    set current(viewItem) {
        this.selected_ = (viewItem === undefined) ? [] : [viewItem];
        this.changedInternal.publish();
    }

    onChanged() {
        console.log("view-onchanged");
        let items = this.getItems().countable();
        this.items_ = items;

        const oldSelected = new IterableX(this.selected_);
        if (!oldSelected.isEmpty()) {
            // Previous selection was not empty

            // Current selection includes previously selected items
            // If previous items not available, select the item at the starting index 
            // Otherwise, select the last item in the view

            let selected = items.filter(vi => oldSelected.some(si => si.item === vi.item)).array();

            // Selection order is important, so use the old order 
            selected = /** @type { ViewItem[] } */ (this.selected_.map(vi => selected.find(si => si.item === vi.item)).filter(x => x !== undefined));

            if (selected.length === 0) {
                if (!items.isEmpty()) {
                    const referenceVI = /** @type { ViewItem } */ (oldSelected.at(0));
                    const item = /** @type { ViewItem } */ (items.at(referenceVI.viewIndex) ?? items.at(-1));
                    selected = [item];
                }
            }

            this.selected_ = selected;

        } else if (!items.isEmpty()) {
            // Previous selection was empty so select the last item in the view
            const item = /** @type { ViewItem } */ (items.at(-1));
            this.selected_ = [item];
        }

        this.changed.publish();
    }

    /**
     * @param { Item } item
     * @param { number } index
     * @param { number } viewIndex
     * @returns { ViewItem }
     */
    viewItem(item, index, viewIndex) {
        const view = this;

        class ViewItem_ {
            /**
             * @param { Item } item 
             * @param { number } index
             * @param { number } viewIndex
             */
            constructor(item, index, viewIndex) {
                this.item_ = item;
                this.index_ = index;
                this.viewIndex_ = viewIndex;
            }

            get item() {
                return this.item_;
            }

            /** The index of the item in the document */
            get index() {
                return this.index_;
            }

            /** The index of the item in the view */
            get viewIndex() {
                return this.viewIndex_;
            }

            get properties() {
                return view.propertyFilter.properties(this.item_);
            }
        }
        return new ViewItem_(item, index, viewIndex);
    }

    /**
     * @returns { IterableX<ViewItem> }
     */
    getItems() {
        const view = this;

        function* items_() {
            let viewIndex = 0;
            for (const [index, item] of view.document.ordered(view.sorting)) {
                if (view.itemFilter.allow(item)) {
                    yield view.viewItem(item, index, viewIndex);
                    ++viewIndex;
                }
            }
        }

        return new IterableX({ [Symbol.iterator]() { return items_(); } });
    }

    /**
     * Returns { min, max, down } of the view indexes in the current selection
     */
    get selectionRange() {
        let max = undefined;
        let maxIndex = 0;
        let min = undefined;
        let minIndex = 0;

        for (const [index, item] of this.selected_.entries()) {
            if ((max === undefined) || item.viewIndex > max) {
                maxIndex = index;
                max = item.viewIndex;
            }

            if ((min === undefined) || item.viewIndex < min) {
                minIndex = index;
                min = item.viewIndex;
            }
        }

        min = min ?? 0;
        max = max ?? 0;

        return { min, max, minIndex, maxIndex };
    }

    deleteSelected() {
        for (const item of this.selected_) {
            this.document.removeItem(item.item);
        }
    }

    selectUp() {
        const range = this.selectionRange;
        const newIndex = Math.max(range.min - 1, 0);
        this.current = this.items_.at(newIndex);
    }

    extendUp() {
        const range = this.selectionRange;
        if (range.minIndex < range.maxIndex) {
            this.selected_.splice(range.maxIndex, 1);
            this.changedInternal.publish();
        } else {
            const newIndex = Math.max(range.min - 1, 0);
            this.addToSelection(this.items_.at(newIndex));
        }
    }

    selectDown() {
        const range = this.selectionRange;
        const newIndex = Math.min(range.max + 1, this.items_.count() - 1);
        this.current = this.items_.at(newIndex);
    }

    extendDown() {
        const range = this.selectionRange;
        if (range.minIndex > range.maxIndex) {
            this.selected_.splice(range.minIndex, 1);
            this.changedInternal.publish();
        } else {
            const newIndex = Math.min(range.max + 1, this.items_.count() - 1);
            this.addToSelection(this.items_.at(newIndex));
        }
    }

    /**
     * 
     * @param { ViewItem } viewItem 
     * @returns 
     */
    extendSelection(viewItem) {
        if (viewItem === undefined) {
            return;
        }

        let range = this.selectionRange;

        if (range.min <= viewItem.viewIndex && viewItem.viewIndex <= range.max) {
            if (range.minIndex <= range.maxIndex) {
                this.selected_ = this.selected_.filter(vi => vi.viewIndex <= viewItem.viewIndex);
            } else {
                this.selected_ = this.selected_.filter(vi => vi.viewIndex >= viewItem.viewIndex);
            }
        }

        // Update the range
        range = this.selectionRange;

        console.log("2nd", range, viewItem.viewIndex)

        if (viewItem.viewIndex <= range.min) {
            for (let i = range.min; i >= viewItem.viewIndex; --i) {
                this.addToSelection(this.items_.at(i));
            }
        } else {
            for (let i = range.max; i <= viewItem.viewIndex; ++i) {
                this.addToSelection(this.items_.at(i));
            }
        }

        this.changedInternal.publish();
    }

    clearSelection() {
        this.selected_ = [];
        this.changedInternal.publish();
    }

    /**
     * 
     * @param { ViewItem | undefined } viewItem 
     */
    addToSelection(viewItem) {
        if (viewItem !== undefined) {
            const exists = this.selected_.some(vi => vi.item === viewItem.item);
            if (!exists) {
                this.selected_.push(viewItem);
                this.changedInternal.publish();
            }
        }
    }

    /**
     * @param { ViewItem | undefined } viewItem 
     */
    toggleSelection(viewItem) {
        if (viewItem === undefined) {
            return;
        }

        const index = this.selected_.findIndex(vi => vi.item === viewItem.item);
        if (index >= 0) {
            if (this.selected_.length > 1) {
                this.selected_.splice(index, 1);
                this.changedInternal.publish();
            }
        } else {
            this.addToSelection(viewItem);
        }
    }

    selectAll() {
        this.selected_ = [...this.items_];
        this.changedInternal.publish();
    }

    /**
     * 
     * @param { ViewItem } viewItem 
     */
    isSelected(viewItem) {
        return this.selected_.some(vi => vi.item === viewItem.item);
    }

    /**
     * 
     * @param { string } text The data to load
     * @param { ViewItem | undefined } [viewItem] Load the data after this item (or the current item)
     */
    load(text, viewItem) {
        viewItem = viewItem ?? this.current;
        const index = (viewItem?.index ?? -1) + 1;
        const range = this.document.load(text, index);

        let indexInView = (viewItem !== undefined) ? viewItem.viewIndex + 1 : this.items_.count();
        for (let documentIndex = range.start; documentIndex < range.end; ++documentIndex) {

            const viewItem = this.viewItem(this.document.items.at(documentIndex), documentIndex, indexInView);
            this.addToSelection(viewItem);
            ++indexInView;
        }
    }

    createItem() {
        console.log("Create-start");
        const current = this.current;

        const indexInView = (current !== undefined) ? current.viewIndex + 1 : this.items_.count();
        const indexInDocument = (current !== undefined) ? current.index + 1 : this.document.items.length;

        const item = this.document.createItem(indexInDocument);

        // Add tags so that the new item shows up in this view
        for (const tag of this.itemFilter.includeTags) {
            item.addValue(TAG, tag);
        }

        const viewItem = this.viewItem(item, indexInDocument, indexInView);

        // Set the new item as the current item
        this.current = viewItem;

        console.log("Create-end");
        return viewItem;
    }
}


/**
 * @template T
 */
export class IterableX {

    /**
     * @param { Iterable<T> & { length?: number | undefined } } items 
     */
    constructor(items) {
        /** @type { Iterable<T> & { length?: number | undefined } }  */
        this.items = items;
    }

    [Symbol.iterator]() {
        return this.items[Symbol.iterator]();
    }

    /**
     * Returns the number of items in the collection
     * iff the underlying collection supports constant time access to that value.
     * If the collection does not support constant time access to the number of items,
     * the length property returns undefined.
     */
    get length() {
        return this.items.length;
    }

    /**
     * Returns the collection as an array.
     * Is not guaranteed to make a copy, so be careful.
     */
    array() {
        if (Array.isArray(this.items)) {
            return /** @type { T[] } */ (this.items);
        }
        return [...this];
    }

    /**
     * Returns an IterableX backed by an array
     * which means you get constant time access to the length and
     * a realization of the results while still allowing access
     * to the IterableX methods. Will return the current object
     * if it's already backed by an array.
     */
    countable() {
        if (Array.isArray(this.items)) {
            return this;
        }
        return new IterableX([...this]);
    }

    /**
     * Returns the number of items in the collection
     */
    count() {
        const l = this.items.length;
        if (l !== undefined) {
            return l;
        }

        let length = 0;
        for (const item of this.items) {
            ++length;
        }

        return length;
    }

    /**
     * @template R
     * @param { (value: T, index: number)=>R } fn 
     */
    map(fn) {
        const items = this.items;

        function* map_() {
            let index = 0;
            for (const item of items) {
                yield fn(item, index);
                ++index;
            }
        }

        const length = this.items.length;

        return new IterableX({ length, [Symbol.iterator]() { return map_(); } });
    }

    /**
     * @template R
     * @param { (value: T, index: number)=>R | undefined } fn 
     */
    filterMap(fn) {
        const items = this.items;

        function* filterMap() {
            let index = 0;
            for (const item of items) {
                const result = fn(item, index);
                if (result !== undefined) {
                    yield result;
                }
                ++index;
            }
        }

        const length = this.items.length;

        return new IterableX({ length, [Symbol.iterator]() { return filterMap(); } });
    }

    /**
     * @param { (value: T, index: number)=>boolean } fn 
     */
    filter(fn) {
        const items = this.items;

        function* filter_() {
            let index = 0;
            for (const item of items) {
                if (fn(item, index)) {
                    yield item;
                }
                ++index;
            }
        }

        return new IterableX({ [Symbol.iterator]() { return filter_(); } });
    }

    /**
     * Returns true if any item matches the predicate.
     * @param { (value: T, index: number)=>boolean } fn 
     */
    some(fn) {
        const items = this.items;

        let index = 0;
        for (const item of items) {
            if (fn(item, index)) {
                return true;
            }
            ++index;
        }

        return false;
    }

    /**
     * Returns true if all items match the predicate.
     * @param { (value: T, index: number)=>boolean } fn 
     */
    every(fn) {
        const items = this.items;

        let index = 0;
        for (const item of items) {
            if (!fn(item, index)) {
                return false;
            }
            ++index;
        }

        return true;
    }

    /**
     * Returns the item at the specified index, or undefined if no item.
     * You can use negative indexes to count from the end of the collection.
     * If you use negative indexes, you may incur the cost of array-backing the collection.
     * @param { number } index 
     * @returns { T | undefined }
     */
    at(index) {
        const length = this.items.length;

        if (index < 0) {
            if (length === undefined) {
                return this.countable().at(index);
            }
            index = length + index;
        }

        if (length !== undefined && index >= length) {
            return undefined;
        }

        if (Array.isArray(this.items)) {
            const items = /** @type { T[] } */ (this.items);
            return items[index];
        }

        let i = 0;
        for (const item of this.items) {
            if (i === index) {
                return item;
            }
            ++i;
        }
    }

    /**
     * Returns [0, item] or undefined
     */
    first() {
        for (const item of this.items) {
            return /** @type { [0, T] } */ ([0, item]);
        }
    }

    /**
     * Returns [index, item] or undefined
     */
    last() {
        if (Array.isArray(this.items)) {
            const index = this.items.length - 1;
            const item = /** @type { T | undefined } */ (this.items[index]);
            if (item !== undefined) {
                return /** @type { [number, T] } */ ([index, item]);
            } else {
                return undefined;
            }
        }

        let last;
        let index = -1;
        for (const item of this.items) {
            ++index;
            last = item;
        }

        if (last !== undefined) {
            return /** @type { [number, T] } */ ([index, last]);
        }
    }

    /**
     * Returns true if there are no items in the collection.
     */
    isEmpty() {
        return this.first() === undefined;
    }

    /**
     * Yields [index, item]
     */
    entries() {
        const items = this.items;

        function* entries_() {
            let index = 0;
            for (const item of items) {
                yield /** @type { [ number, T] } */ ([index, item]);
                ++index;
            }
        }

        const length = items.length;

        return new IterableX({ length, [Symbol.iterator]() { return entries_(); } });
    }

    /**
     * Reverses the collection.
     * Cheap if the underlying collection is an array.
     * Otherwise, creates an array first.
     * @returns { IterableX<T> }
     */
    reverse() {
        // If not array-backed, create an array-backed iterable then reverse it.
        // If array-backed, use the indexer and iterate from high to low indexes.

        if (!Array.isArray(this.items)) {
            return new IterableX([...this]).reverse();
        }

        const items = /** @type { T[] } */ (this.items);
        function* reverse_() {
            for (let i = items.length - 1; i >= 0; --i) {
                yield items[i];
            }
        }

        const length = items.length;

        return new IterableX({ length, [Symbol.iterator]() { return reverse_(); } });
    }

    /**
     * Skips the first count items
     * @param { number } count
     */
    skip(count) {
        const items = this.items;

        function* skip_() {
            if (Array.isArray(items)) {
                for (let i = count; i < items.length; ++i) {
                    yield /** @type {T} */ (items[i]);
                }
                return;
            }

            let skipped = 0;
            for (const item of items) {
                if (skipped < count) {
                    ++skipped;
                    continue;
                }
                yield item;
            }
        }

        let length = items.length;
        if (length !== undefined) {
            length = Math.max(0, length - count);
        }

        return new IterableX({ length, [Symbol.iterator]() { return skip_(); } });
    }

    /**
     * Yields only the first count items
     * @param { number } count
     */
    take(count) {
        const items = this.items;

        function* take_() {
            let taken = 0;
            for (const item of items) {
                if (taken >= count) {
                    break;
                }
                yield item;
                ++taken;
            }
        }

        let length = items.length;
        if (length !== undefined) {
            length = Math.min(length, count);
        }

        return new IterableX({ length, [Symbol.iterator]() { return take_(); } });
    }

    /**
     * Returns [index, item] of the first item to match.
     * @param { (item: T, index: number)=>boolean } fn 
     */
    find(fn) {
        let index = 0;
        for (const item of this.items) {
            if (fn(item, index)) {
                return /** @type { [number, T] } */ ([index, item]);
            }
            ++index;
        }
    }
}

/**
 * @param { Document } document 
 * @param { string | PropertyKey } property 
 * @param { ValueToken } valueToken 
 * @param { string } line 
 */
function valueTokenToObject(document, property, valueToken, line) {
    if (valueToken.isReference(line)) {
        /** @type { string } */
        let relation = "";
        /** @type { string[] } */
        let target = [];
        for (const token of valueToken.tokens(line)) {
            if (token instanceof RelationToken) {
                relation = token.text(line);
            } else if (token instanceof TargetToken) {
                target = token.text(line).split(".");
            }
        }
        return document.createReference(relation, target)
    } else {
        const levels = valueToken.tokens(line).filter(token => token instanceof HierarchyToken).map(token => token.text(line));
        return document.createHierarchy(property, levels);
    }
}

/**
 * @param { Document } document 
 * @param { string | PropertyKey } property 
 * @param { string } line 
 * @returns { ( ValueHierarchy | ValueReference | ValueText)[] }
 */
export function parseValues(document, property, line) {
    const propertyKey = document.ensurePropertyKey(property);
    if (TEXT_PROPERTIES.includes(propertyKey.key)) {
        return [document.createText(line.trim())];
    }
    const values = /** @type { ValueToken[] } */ (new ValuesToken(0, line.length).tokens(line).filter(t => t instanceof ValueToken));
    const result = values.map(token => valueTokenToObject(document, property, token, line));
    return result;
}

export function _use() {
    const x = new IterableX([1, 2, 3, 4, 5, 6]).skip(2).take(3).map((i) => i * 2).countable();
    console.log([...x], x.count());
    console.log([...x.filter(i => i > 6).reverse()]);


    const doc = new Document("test");

    const item = doc.createItem();

    // const idProperty = item.ensureProperty("ID");
    // const idValue = doc.createHierarchy("ID", ["My ID"]);
    // idProperty.setValues([idValue]);

    item.addValue("ID", ["My ID"]);

    const timeProperty = item.createProperty("Time");
    const timeValue = doc.createReference("before", ["My ID"]);
    timeProperty.addValue(timeValue);

    item.addValue("title", "My Excellent Title");

    item.addValue("title", "My Excellent Title II");

    item.addValue("Custom", ["Shop 1", "Room 2"]);
    item.addValue("Custom", ["Shop 1", "Room A"]);

    item.setValue("Content", `This is the main content and it's pretty great!`);

    item.addValue("Tag", ["My Tag"]);
    item.addValue("Tag", ["Tag2"]);
    item.addValue("Tag", ["Whatevs"]);

    const item2 = doc.createItem();
    item2.setValue("ID", ["The 2nd Item"]);
    item2.addTag("Tag1");
    item2.addTag("Tag2");
    item2.addTag("Multi-word Tag, with, commas");

    // const c = new Cursor(doc.items);

    const view = new View(doc);
    // view.itemFilter.includeTags = ["Tag2"].map(n => doc.createTag(n));
    view.propertyFilter.include = ["id", "title", "content", "tag", "sequence", "note"].map(n => doc.propertyKeys.ensureKey(n));

    view.current = view.items.at(0);

    const item3 = view.createItem();
    item3.item.addTag("Tag2");
    item3.item.addTag("ITEM3");

    // @ts-ignore
    view.addToSelection(view.items.at(0));

    const item4 = view.createItem();
    item4.item.addTag("Tag2");
    item4.item.addTag("ITEM4");

    return doc;
}